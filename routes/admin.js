const express = require("express");
const { body, validationResult, query } = require("express-validator");
const admin = require("firebase-admin");
const jwt = require("jsonwebtoken"); // Import jsonwebtoken
const router = express.Router();

const db = admin.firestore();

// Middleware to verify admin authentication
const verifyAdmin = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "Authorization header is required"
      });
    }

    const token = authHeader.split("Bearer ")[1];
    let decodedToken;

    try {
      // Verify the JWT token generated by auth.js
      decodedToken = jwt.verify(token, process.env.JWT_SECRET || "fallback-secret");
    } catch (jwtError) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "Invalid or expired token"
      });
    }

    // Get user role from Firestore using the UID from the decoded JWT
    const userDoc = await db.collection("users").doc(decodedToken.uid).get();
    const userData = userDoc.data();
    
    if (!userData || userData.role !== "admin") {
      return res.status(403).json({
        error: "Access denied",
        message: "Admin access required"
      });
    }

    req.user = { ...decodedToken, role: userData.role };
    next();
  } catch (error) {
    console.error("Admin verification error:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: error.message
    });
  }
};

// Dashboard statistics
router.get("/dashboard", verifyAdmin, async (req, res) => {
  try {
    const { period = "30" } = req.query; // days
    const periodDays = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);

    // Get orders statistics
    const ordersQuery = await db.collection("orders")
      .where("createdAt", ">=", startDate)
      .get();

    let totalRevenue = 0;
    let totalOrders = ordersQuery.size;
    let completedOrders = 0;
    let pendingOrders = 0;
    const dailyStats = {};

    ordersQuery.forEach(doc => {
      const order = doc.data();
      const orderDate = order.createdAt.toDate().toDateString();
      
      if (!dailyStats[orderDate]) {
        dailyStats[orderDate] = { orders: 0, revenue: 0 };
      }
      
      dailyStats[orderDate].orders += 1;
      dailyStats[orderDate].revenue += order.orderSummary?.finalTotal || 0;
      
      totalRevenue += order.orderSummary?.finalTotal || 0;
      
      if (order.status === "delivered") {
        completedOrders += 1;
      } else if (order.status === "pending") {
        pendingOrders += 1;
      }
    });

    // Get products statistics
    const productsQuery = await db.collection("products").get();
    let totalProducts = 0;
    let activeProducts = 0;
    let lowStockProducts = 0;

    productsQuery.forEach(doc => {
      const product = doc.data();
      totalProducts += 1;
      
      if (product.isActive) {
        activeProducts += 1;
      }
      
      if (product.inventory <= 10) {
        lowStockProducts += 1;
      }
    });

    // Get users statistics
    const usersQuery = await db.collection("users")
      .where("createdAt", ">=", startDate)
      .get();
    
    const newUsers = usersQuery.size;

    // Get total users
    const totalUsersQuery = await db.collection("users").get();
    const totalUsers = totalUsersQuery.size;

    // Top selling products
    const topProductsQuery = await db.collection("products")
      .where("soldCount", ">", 0)
      .orderBy("soldCount", "desc")
      .limit(5)
      .get();

    const topProducts = [];
    topProductsQuery.forEach(doc => {
      topProducts.push({
        id: doc.id,
        ...doc.data()
      });
    });

    // Recent orders
    const recentOrdersQuery = await db.collection("orders")
      .orderBy("createdAt", "desc")
      .limit(10)
      .get();

    const recentOrders = [];
    recentOrdersQuery.forEach(doc => {
      const orderData = doc.data();
      recentOrders.push({
        id: doc.id,
        orderId: orderData.orderId,
        userId: orderData.userId,
        status: orderData.status,
        total: orderData.orderSummary?.finalTotal,
        itemCount: orderData.items?.length,
        createdAt: orderData.createdAt?.toDate()
      });
    });

    res.json({
      success: true,
      dashboard: {
        overview: {
          totalRevenue,
          totalOrders,
          completedOrders,
          pendingOrders,
          totalProducts,
          activeProducts,
          lowStockProducts,
          totalUsers,
          newUsers
        },
        trends: {
          dailyStats: Object.entries(dailyStats).map(([date, stats]) => ({
            date,
            ...stats
          }))
        },
        topProducts,
        recentOrders
      }
    });

  } catch (error) {
    console.error("Get dashboard error:", error);
    res.status(500).json({
      error: "Failed to fetch dashboard data",
      message: error.message
    });
  }
});

// Get all orders (admin)
router.get("/orders", verifyAdmin, [
  query("limit").optional().isInt({ min: 1, max: 100 }),
  query("page").optional().isInt({ min: 1 }),
  query("status").optional().isString(),
  query("search").optional().isString()
], async (req, res) => {
  try {
    const { limit = 20, page = 1, status, search } = req.query;

    let query = db.collection("orders").orderBy("createdAt", "desc");

    if (status && status !== "all") {
      query = query.where("status", "==", status);
    }

    // Apply pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);
    if (offset > 0) {
      const offsetSnapshot = await query.limit(offset).get();
      if (!offsetSnapshot.empty) {
        const lastDoc = offsetSnapshot.docs[offsetSnapshot.docs.length - 1];
        query = query.startAfter(lastDoc);
      }
    }

    query = query.limit(parseInt(limit));
    const snapshot = await query.get();

    const orders = [];
    for (const doc of snapshot.docs) {
      const orderData = doc.data();
      
      // Get user details
      let userDetails = null;
      if (orderData.userId) {
        const userDoc = await db.collection("users").doc(orderData.userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          userDetails = {
            firstName: userData.firstName,
            lastName: userData.lastName,
            email: userData.email
          };
        }
      }

      // Apply search filter
      if (search) {
        const searchTerm = search.toLowerCase();
        const orderIdMatch = orderData.orderId?.toLowerCase().includes(searchTerm);
        const userMatch = userDetails && (
          userDetails.firstName?.toLowerCase().includes(searchTerm) ||
          userDetails.lastName?.toLowerCase().includes(searchTerm) ||
          userDetails.email?.toLowerCase().includes(searchTerm)
        );
        
        if (!orderIdMatch && !userMatch) continue;
      }

      orders.push({
        id: doc.id,
        ...orderData,
        userDetails,
        createdAt: orderData.createdAt?.toDate(),
        updatedAt: orderData.updatedAt?.toDate(),
        estimatedDelivery: orderData.estimatedDelivery?.toDate()
      });
    }

    // Get total count for pagination
    let countQuery = db.collection("orders");
    if (status && status !== "all") {
      countQuery = countQuery.where("status", "==", status);
    }
    const countSnapshot = await countQuery.get();
    const totalOrders = countSnapshot.size;
    const totalPages = Math.ceil(totalOrders / parseInt(limit));

    res.json({
      success: true,
      orders,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalOrders,
        hasNextPage: parseInt(page) < totalPages,
        hasPrevPage: parseInt(page) > 1
      }
    });

  } catch (error) {
    console.error("Get admin orders error:", error);
    res.status(500).json({
      error: "Failed to fetch orders",
      message: error.message
    });
  }
});

// Update order status
router.put("/orders/:orderId/status", verifyAdmin, [
  body("status").isIn(["pending", "confirmed", "processing", "shipped", "delivered", "cancelled"]).withMessage("Invalid status"),
  body("trackingNumber").optional().isString(),
  body("notes").optional().isString()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: "Validation failed",
        details: errors.array()
      });
    }

    const { orderId } = req.params;
    const { status, trackingNumber, notes } = req.body;

    const orderDoc = await db.collection("orders").doc(orderId).get();
    
    if (!orderDoc.exists) {
      return res.status(404).json({
        error: "Order not found"
      });
    }

    const orderData = orderDoc.data();
    const updateData = {
      status,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: req.user.uid
    };

    if (trackingNumber) {
      updateData.trackingNumber = trackingNumber;
    }

    if (notes) {
      updateData.adminNotes = notes;
    }

    // Set delivery date if status is delivered
    if (status === "delivered") {
      updateData.deliveredAt = admin.firestore.FieldValue.serverTimestamp();
    }

    await db.collection("orders").doc(orderId).update(updateData);

    // Emit real-time update to user
    req.io.to(`user-${orderData.userId}`).emit("order-status-updated", {
      orderId: orderData.orderId,
      status,
      trackingNumber
    });

    // Emit to admin dashboard
    req.io.to("admin").emit("order-updated", {
      orderId: orderData.orderId,
      status,
      updatedBy: req.user.uid
    });

    res.json({
      success: true,
      message: "Order status updated successfully"
    });

  } catch (error) {
    console.error("Update order status error:", error);
    res.status(500).json({
      error: "Failed to update order status",
      message: error.message
    });
  }
});

// Create product
router.post("/products", verifyAdmin, [
  body("name").trim().isLength({ min: 1 }).withMessage("Product name is required"),
  body("description").trim().isLength({ min: 1 }).withMessage("Description is required"),
  body("price").isFloat({ min: 0 }).withMessage("Price must be a positive number"),
  body("category").notEmpty().withMessage("Category is required"),
  body("brand").notEmpty().withMessage("Brand is required"),
  body("inventory").isInt({ min: 0 }).withMessage("Inventory must be a non-negative integer"),
  body("images").isArray({ min: 1 }).withMessage("At least one image is required")
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: "Validation failed",
        details: errors.array()
      });
    }

    const productData = {
      ...req.body,
      isActive: true,
      isFeatured: req.body.isFeatured || false,
      soldCount: 0,
      rating: 0,
      reviewCount: 0,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      createdBy: req.user.uid
    };

    const productRef = await db.collection("products").add(productData);

    // Emit real-time update
    req.io.to("admin").emit("product-created", {
      productId: productRef.id,
      name: productData.name,
      createdBy: req.user.uid
    });

    res.status(201).json({
      success: true,
      message: "Product created successfully",
      productId: productRef.id
    });

  } catch (error) {
    console.error("Create product error:", error);
    res.status(500).json({
      error: "Failed to create product",
      message: error.message
    });
  }
});

// Update product
router.put("/products/:productId", verifyAdmin, [
  body("name").optional().trim().isLength({ min: 1 }).withMessage("Product name cannot be empty"),
  body("description").optional().trim().isLength({ min: 1 }).withMessage("Description cannot be empty"),
  body("price").optional().isFloat({ min: 0 }).withMessage("Price must be a positive number"),
  body("inventory").optional().isInt({ min: 0 }).withMessage("Inventory must be a non-negative integer")
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: "Validation failed",
        details: errors.array()
      });
    }

    const { productId } = req.params;
    
    const productDoc = await db.collection("products").doc(productId).get();
    
    if (!productDoc.exists) {
      return res.status(404).json({
        error: "Product not found"
      });
    }

    const updateData = {
      ...req.body,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedBy: req.user.uid
    };

    await db.collection("products").doc(productId).update(updateData);

    // Emit real-time update
    req.io.to("admin").emit("product-updated", {
      productId,
      updatedBy: req.user.uid
    });

    res.json({
      success: true,
      message: "Product updated successfully"
    });

  } catch (error) {
    console.error("Update product error:", error);
    res.status(500).json({
      error: "Failed to update product",
      message: error.message
    });
  }
});

// Delete product
router.delete("/products/:productId", verifyAdmin, async (req, res) => {
  try {
    const { productId } = req.params;
    
    const productDoc = await db.collection("products").doc(productId).get();
    
    if (!productDoc.exists) {
      return res.status(404).json({
        error: "Product not found"
      });
    }

    // Soft delete - just mark as inactive
    await db.collection("products").doc(productId).update({
      isActive: false,
      deletedAt: admin.firestore.FieldValue.serverTimestamp(),
      deletedBy: req.user.uid
    });

    // Emit real-time update
    req.io.to("admin").emit("product-deleted", {
      productId,
      deletedBy: req.user.uid
    });

    res.json({
      success: true,
      message: "Product deleted successfully"
    });

  } catch (error) {
    console.error("Delete product error:", error);
    res.status(500).json({
      error: "Failed to delete product",
      message: error.message
    });
  }
});

// Get all users (admin)
router.get("/users", verifyAdmin, [
  query("limit").optional().isInt({ min: 1, max: 100 }),
  query("page").optional().isInt({ min: 1 }),
  query("search").optional().isString()
], async (req, res) => {
  try {
    const { limit = 20, page = 1, search } = req.query;

    let query = db.collection("users").orderBy("createdAt", "desc");

    // Apply pagination
    const offset = (parseInt(page) - 1) * parseInt(limit);
    if (offset > 0) {
      const offsetSnapshot = await query.limit(offset).get();
      if (!offsetSnapshot.empty) {
        const lastDoc = offsetSnapshot.docs[offsetSnapshot.docs.length - 1];
        query = query.startAfter(lastDoc);
      }
    }

    query = query.limit(parseInt(limit));
    const snapshot = await query.get();

    const users = [];
    snapshot.forEach(doc => {
      const userData = doc.data();
      
      // Apply search filter
      if (search) {
        const searchTerm = search.toLowerCase();
        const nameMatch = userData.firstName?.toLowerCase().includes(searchTerm) ||
                          userData.lastName?.toLowerCase().includes(searchTerm);
        const emailMatch = userData.email?.toLowerCase().includes(searchTerm);
        
        if (!nameMatch && !emailMatch) return;
      }

      // Remove sensitive information
      const { password, ...safeUserData } = userData;
      
      users.push({
        id: doc.id,
        ...safeUserData,
        createdAt: userData.createdAt?.toDate(),
        updatedAt: userData.updatedAt?.toDate(),
        lastLogin: userData.lastLogin?.toDate()
      });
    });

    // Get total count
    const countSnapshot = await db.collection("users").get();
    const totalUsers = countSnapshot.size;
    const totalPages = Math.ceil(totalUsers / parseInt(limit));

    res.json({
      success: true,
      users,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalUsers,
        hasNextPage: parseInt(page) < totalPages,
        hasPrevPage: parseInt(page) > 1
      }
    });

  } catch (error) {
    console.error("Get admin users error:", error);
    res.status(500).json({
      error: "Failed to fetch users",
      message: error.message
    });
  }
});

// Create coupon
router.post("/coupons", verifyAdmin, [
  body("code").trim().isLength({ min: 3 }).withMessage("Coupon code must be at least 3 characters"),
  body("type").isIn(["percentage", "fixed", "freeShipping", "buy2get1", "buy3special"]).withMessage("Invalid coupon type"),
  body("value").isFloat({ min: 0 }).withMessage("Value must be a positive number"),
  body("expiryDate").isISO8601().withMessage("Invalid expiry date"),
  body("description").trim().isLength({ min: 1 }).withMessage("Description is required")
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: "Validation failed",
        details: errors.array()
      });
    }

    const couponCode = req.body.code.toUpperCase();
    
    // Check if coupon already exists
    const existingCoupon = await db.collection("coupons").doc(couponCode).get();
    
    if (existingCoupon.exists) {
      return res.status(409).json({
        error: "Coupon already exists",
        message: "A coupon with this code already exists"
      });
    }

    const couponData = {
      ...req.body,
      code: couponCode,
      isActive: true,
      usedCount: 0,
      expiryDate: admin.firestore.Timestamp.fromDate(new Date(req.body.expiryDate)),
      startDate: req.body.startDate ? admin.firestore.Timestamp.fromDate(new Date(req.body.startDate)) : null,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      createdBy: req.user.uid
    };

    await db.collection("coupons").doc(couponCode).set(couponData);

    res.status(201).json({
      success: true,
      message: "Coupon created successfully",
      couponCode
    });

  } catch (error) {
    console.error("Create coupon error:", error);
    res.status(500).json({
      error: "Failed to create coupon",
      message: error.message
    });
  }
});





module.exports = router;



router.post("/seed-database", verifyAdmin, require("../database/productsSeed"));


